<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Visor 3D Regalo (v16.1 - Interacción y Raycasting)</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { width: 100%; height: 100%; display: block; }
        #loading-indicator {
             position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
             color: black; font-family: sans-serif; font-size: 1.2em; display: block;
             background-color: rgba(255, 255, 255, 0.8);
             padding: 10px; border-radius: 5px; text-align: center;
        }
        /* --- ESTILOS DEL CONFETI --- */
        #texto-confeti { position:absolute; top: 0; left: 0; z-index:10; pointer-events:none; }
        #entrada-confeti { display:none; /* Oculto por ahora */ }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "/assets/html3d/libs/three/build/three.module.js",
                "three/addons/": "/assets/html3d/libs/three/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="loading-indicator">Cargando visor v16.1...</div>

<!-- --- ELEMENTOS HTML Y SHADERS DEL CONFETI --- -->
<canvas id="texto-confeti" width="800" height="200"></canvas>
<input id="entrada-confeti" type="text" value="DESEAMOS QUE HAYAS DISFRUTADO ESTA EXPERIENCIA" />

<script id="vs-confeti" type="x-shader/x-vertex">

    attribute vec2 anim;
    attribute vec3 desplazamiento;
    attribute vec3 control0;
    attribute vec3 control1;
    attribute vec4 giro;
    attribute vec3 colorF;
    attribute vec3 colorT;
    uniform float tiempo;
    varying vec3 vColorF;
    varying vec3 vColorT;

    vec3 rotar(vec4 q, vec3 v){
      return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
    }

    vec4 ejeAngulo(vec3 eje, float ang){
      float ha = ang * 0.5;
      return vec4(eje.xyz * sin(ha), cos(ha));
    }

    vec3 bezier(vec3 p0, vec3 p1, vec3 c0, vec3 c1, float t){
      float inv = 1.0 - t;
      return inv*inv*inv*p0 + 3.0*inv*inv*t*c0 + 3.0*inv*t*t*c1 + t*t*t*p1;
    }

    float ease(float t, float d){
      t = clamp(t/d, 0.0, 1.0) - 1.0;
      return -(t*t*t*t - 1.0);
    }

    void main(){
      float tt = clamp(tiempo - anim.x, 0.0, anim.y);
      float prog = ease(tt, anim.y);

      vec3 pos = position;
      vec4 q = ejeAngulo(giro.xyz, giro.w * prog);
      pos = rotar(q, pos);

      vec3 p0 = pos;
      vec3 p1 = pos + desplazamiento;
      pos = bezier(p0, p1, pos + control0, pos + control1, prog);

      vColorF = colorF;
      vColorT = colorT;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
  </script>

<script id="fs-confeti" type="x-shader/x-fragment">

    varying vec3 vColorF;
    varying vec3 vColorT;
    void main(){
      gl_FragColor = gl_FrontFacing ? vec4(vColorF,1.0) : vec4(vColorT,1.0);
    }
  </script>
<!-- --- FIN ELEMENTOS DEL CONFETI --- -->

<!-- ================================================================== -->
<!-- === FUNCIONES DEL CONFETI ADAPTADAS Y AÑADIDAS A WINDOW ========== -->
<!-- ================================================================== -->
<script>
    // Ponemos las funciones aquí, en un script normal, para que estén disponibles globalmente
    // antes de que el script de tipo "module" se ejecute.

    window.crearMeshConfeti = function() {
        // ... (El código de la función crearMeshConfeti que ya tienes) ...
        // ... No cambia nada dentro de la función ...
    };

    window.prepararTextoConfeti = function() {
        // ... (El código de la función prepararTextoConfeti que ya tienes) ...
    };

    window.actualizarTextoConfeti = function() {
        // ... (El código de la función actualizarTextoConfeti que ya tienes) ...
    };

    window.crearCubosConfeti = function() {
        // ... (El código de la función crearCubosConfeti que ya tienes) ...
    };

    window.actualizarCubosConfeti = function() {
        // ... (El código de la función actualizarCubosConfeti que ya tienes) ...
    };

    window.iniciarAnimacionConfetiCompleta = function() {
        // ... (El código de la función iniciarAnimacionConfetiCompleta que ya tienes) ...
    };

    window.detenerAnimacionConfeti = function() {
        // ... (El código de la función detenerAnimacionConfeti que ya tienes) ...
    };

    function rand(a,b){ return Math.random()*(b-a)+a; }
</script>

<script type="module">
    (async () => {
        console.log("VIEWER.HTML: Script module started (v16.1).");
        const loadingIndicator = document.getElementById('loading-indicator');
        loadingIndicator.textContent = 'Importando módulos JS (v16.1)...';

        try {
            const THREE = await import('three');
            const { GLTFLoader } = await import('three/addons/loaders/GLTFLoader.js');
            const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
            const { DRACOLoader } = await import('three/addons/libs/draco/gltf/DRACOLoader.js');
            console.log("VIEWER.HTML: Módulos importados OK (v16.1).");
            loadingIndicator.textContent = 'Módulos JS OK. Inicializando 3D...';

            if (!THREE || !GLTFLoader || !OrbitControls || !DRACOLoader) {
                 throw new Error("VIEWER.HTML: ¡Fallo al importar módulos!");
            }

            let scene, camera, renderer, controls, gltfModel = null;
            let mixer, clock, animations = [];
            const textureLoader = new THREE.TextureLoader();

            // --- VARIABLES GLOBALES PARA EL CONFETI ---
            var pasoConfeti = 1/60,
                totalConfeti = 150000,
                lienzoTextoConfeti, ctxTextoConfeti, pixelesConfeti=[],
                grupoTextoConfeti, cubosConfeti=[],
                mostrarConfeti=false,
                tiempoConfeti=0,
                meshConfeti;

            // ----- INICIO BLOQUE A AÑADIR 1 -----
            // --- Para Raycasting ---
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            // --- Estado de la aplicación 3D ---
            let estadoApp3D = "INICIO"; // Posibles: INICIO, ANIMANDO_SOLAPA, ANIMANDO_TARJETA, TARJETA_MOSTRADA, TARJETA_LEIDA, ABRIENDO_REGALO
            // ----- FIN BLOQUE A AÑADIR 1 -----

            // --- NOMBRES DE OBJETOS ---
            const NOMBRE_CAJA = "Caja";
            const NOMBRE_MESA = "Mesa_Apoyo";
            const NOMBRE_PAPEL_FRONTAL = "Papel_Frontal";
            const NOMBRE_PAPEL_TRASERO = "Papel_Trasero";
            const NOMBRE_PAPEL_IZQUIERDO = "Papel_Izquierdo";
            const NOMBRE_PAPEL_DERECHO = "Papel_Derecho";
            const NOMBRE_PAPEL_INFERIOR = "Papel_Inferior";
            const NOMBRE_PAPEL_SUPERIOR = "Papel_Superior";
            const NOMBRE_SOBRE = "Sobre";
            const NOMBRE_SOLAPA = "Solapa";
            const NOMBRE_TARJETA = "Tarjeta";
            const NOMBRE_TAPA = "Tapa";
            const NOMBRE_CINTA1 = "Cinta1";
            const NOMBRE_CINTA2 = "Cinta2";
            const NOMBRE_LAZO_ESTRELLA = "Lazoestrella";
            const NOMBRE_LAZO_FLOR = "Lazoflor";
            const NOMBRE_LAZO_NORMAL = "Lazonormal"; // Añadido
            const NOMBRE_LAZO_DORADO = "Lazodorado"; // Añadido

            init();
            animate();

            function init() {
                console.log("VIEWER.HTML: init() v16.1.");
                scene = new THREE.Scene();
                scene.background = null;
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                clock = new THREE.Clock();

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.8, 5); camera.lookAt(0, 0.5, 0);

                // --- INICIALIZACIÓN DEL CONFETI ---
                window.crearMeshConfeti(); // Creamos el objeto de confeti
                window.prepararTextoConfeti(); // Preparamos el canvas del texto
                // --- FIN INICIALIZACIÓN CONFETI ---

                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                document.body.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); directionalLight.position.set(5, 10, 7); scene.add(directionalLight);

                controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.target.set(0, 0.5, 0);

                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('/assets/html3d/libs/three/examples/jsm/libs/draco/gltf/');

                const loader = new GLTFLoader();
                loader.setDRACOLoader(dracoLoader);

                const modelPath = '/assets/texturas/packages/caja_base.glb';
                console.log(`VIEWER.HTML: Cargando GLB: ${modelPath} (v16.1)`);
                loadingIndicator.textContent = 'Cargando modelo 3D (v16.1)...';
                loader.load( modelPath,
                     function (gltf) {
                         console.log("VIEWER.HTML: GLB cargado (v16.1).");
                         loadingIndicator.style.display = 'none';
                         gltfModel = gltf.scene;
                         scene.add(gltfModel);

                         const cajaObj = gltfModel.getObjectByName(NOMBRE_CAJA);
                         if (cajaObj) {
                            const box = new THREE.Box3().setFromObject(cajaObj);
                            const center = box.getCenter(new THREE.Vector3());
                            gltfModel.position.y -= center.y;
                            controls.target.copy(cajaObj.position);
                            controls.target.y += box.getSize(new THREE.Vector3()).y / 2;
                         } else {
                            console.warn("Caja no encontrada para centrar (v16.1).");
                            const box = new THREE.Box3().setFromObject(gltf.scene);
                            const center = box.getCenter(new THREE.Vector3());
                            gltfModel.position.y -= center.y;
                         }
                         console.log("VIEWER.HTML: Modelo posicionado (v16.1).");

                         const piezasPapelNombres = [
                            NOMBRE_PAPEL_FRONTAL, NOMBRE_PAPEL_TRASERO, NOMBRE_PAPEL_IZQUIERDO,
                            NOMBRE_PAPEL_DERECHO, NOMBRE_PAPEL_INFERIOR, NOMBRE_PAPEL_SUPERIOR
                         ];
                         const visiblesPorDefecto = [
                            NOMBRE_CAJA, NOMBRE_MESA, NOMBRE_SOBRE, NOMBRE_SOLAPA,
                            NOMBRE_TAPA, NOMBRE_CINTA1, NOMBRE_CINTA2
                         ];
                         const ocultosPorDefecto = [
                            NOMBRE_TARJETA, ...piezasPapelNombres, NOMBRE_LAZO_ESTRELLA, NOMBRE_LAZO_FLOR,
                            NOMBRE_LAZO_NORMAL, NOMBRE_LAZO_DORADO // Asegurar que estén ocultos
                         ];

                         gltf.scene.traverse(function(child){
                             if(child.isMesh){
                                 if (visiblesPorDefecto.includes(child.name)) {
                                     child.visible = true;
                                 } else if (ocultosPorDefecto.includes(child.name)) {
                                     child.visible = false;
                                 }
                             }
                         });

                         if(gltf.animations && gltf.animations.length > 0){
                             mixer = new THREE.AnimationMixer(gltf.scene);
                             animations = gltf.animations;
                             console.log("Animaciones encontradas (v16.1):", animations.map(a => a.name));
                         } else { console.log("No se encontraron animaciones (v16.1)."); }

                         window.modeloEstaListo = true;

                         // !!!!! LÍNEA DE DEPURACIÓN !!!!!
                         // Forzamos el inicio del confeti aquí para ver si se renderiza
                         window.iniciarAnimacionConfetiCompleta(() => { console.log("Callback de prueba del confeti ejecutado después de 14s"); });

                         // !!!!! BORRA LA LÍNEA DE DEPURACIÓN ANTERIOR !!!!!
                         // window.iniciarAnimacionConfetiCompleta(() => { console.log("Callback de prueba del confeti ejecutado después de 14s"); });

                         console.log("VIEWER.HTML: Modelo listo (v16.1).");
                     },
                     (xhr) => { loadingIndicator.textContent = `Cargando: ${(xhr.loaded / xhr.total * 100).toFixed(0)}% (v16.1)`; },
                     (error) => {
                          console.error('VIEWER.HTML: Error cargando GLB (v16.1):', JSON.stringify(error, Object.getOwnPropertyNames(error)));
                          loadingIndicator.textContent = 'Error al cargar modelo (v16.1).';
                      }
                );
                // --- NUEVO: Event Listener para Clics/Toques en el Canvas ---
                renderer.domElement.addEventListener('pointerdown', onCanvasPointerDown, false);
                // --- FIN NUEVO ---
                window.addEventListener('resize', onWindowResize, false);
                console.log("VIEWER.HTML: init() finalizado (v16.1).");
            }

            function onWindowResize() {
                if(camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                if (controls) controls.update();
                if (mixer) mixer.update(delta);

                // --- LÓGICA DE ANIMACIÓN DEL CONFETI ---
                if (mostrarConfeti) {
                    tiempoConfeti += pasoConfeti;
                    if (meshConfeti) meshConfeti.material.uniforms.tiempo.value = tiempoConfeti;
                    // La animación de los cubos de texto también se actualiza aquí
                    if (cubosConfeti.length > 0) {
                        window.actualizarCubosConfeti();
                    }

                }
                // --- FIN LÓGICA CONFETI ---

                if (renderer && scene && camera) renderer.render(scene, camera);
            }

            // --- NUEVA FUNCIÓN: Manejador de Clics/Toques ---
            function onCanvasPointerDown(event) {
                // Normalizar coordenadas del puntero
                pointer.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                pointer.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                if (!gltfModel) return;
                const intersects = raycaster.intersectObject(gltfModel, true); // true para recursivo

                if (intersects.length > 0) {
                    const primerObjetoTocado = intersects[0].object;
                    // Solo reaccionar si el objeto tocado es una malla y es visible
                    if (!primerObjetoTocado.isMesh || !primerObjetoTocado.visible) return;

                    console.log(`JS: Tocado objeto: ${primerObjetoTocado.name} en estado: ${estadoApp3D}`);

                    // Dentro de onCanvasPointerDown, después de if (intersects.length > 0) { ... }
                    // ... (el console.log que ya tenías)

                    // Dentro de onCanvasPointerDown
                    if (estadoApp3D === "INICIO" && (primerObjetoTocado.name === NOMBRE_SOBRE || primerObjetoTocado.name === NOMBRE_SOLAPA) ) {
                        console.log("JS: Interacción INICIO -> Reproduciendo Solapa_Abrir y Tarjeta_Salir.");
                        estadoApp3D = "ANIMANDO_SOBRE_TARJETA";

                        // Hacer visible la tarjeta si no lo está ya (la animación la moverá)
                        const tarjetaObj = gltfModel.getObjectByName(NOMBRE_TARJETA);
                        if (tarjetaObj && !tarjetaObj.visible) {
                            tarjetaObj.visible = true;
                            console.log("JS: Tarjeta hecha visible para animación.");
                        }

                        // Reproducir ambas acciones. Los nombres vienen de tus capturas.
                        const accionSolapa = window.playAnimacion("Solapa_Abrir");
                        const accionTarjeta = window.playAnimacion("Tarjeta_Salir");

                        if (accionSolapa && accionTarjeta) {
                            // Para saber cuándo la secuencia completa ha terminado, necesitamos
                            // escuchar el evento 'finished' de la acción MÁS LARGA.
                            // Asumimos que ambas terminan alrededor del mismo tiempo (ej: fotograma 50).
                            // O podemos tomar la duración de una de ellas si son iguales.

                            let animacionesTerminadas = 0;
                            const totalAnimaciones = 2;

                            const onAnimFinished = () => {
                                animacionesTerminadas++;
                                if (animacionesTerminadas === totalAnimaciones) {
                                    // Solo cambiar estado si aún estamos en el proceso de esta animación
                                    if (estadoApp3D === "ANIMANDO_SOBRE_TARJETA") {
                                        console.log("JS: Animaciones Solapa_Abrir y Tarjeta_Salir finalizadas. Estado -> TARJETA_MOSTRADA.");
                                        estadoApp3D = "TARJETA_MOSTRADA";
                                    }
                                    // Quitar listeners para evitar múltiples llamadas si se reproducen de nuevo
                                    if (mixer) { // Verificar que mixer exista
                                        mixer.removeEventListener('finished', onSolapaFinished);
                                        mixer.removeEventListener('finished', onTarjetaFinished);
                                    }
                                }
                            };

                            const onSolapaFinished = (event) => {
                                if (event.action === accionSolapa) {
                                    console.log("JS: Solapa_Abrir (acción individual) finalizada.");
                                    onAnimFinished();
                                }
                            };
                            const onTarjetaFinished = (event) => {
                                if (event.action === accionTarjeta) {
                                    console.log("JS: Tarjeta_Salir (acción individual) finalizada.");
                                    onAnimFinished();
                                }
                            };

                            if (mixer) { // Verificar que mixer exista antes de añadir listeners
                                 mixer.addEventListener('finished', onSolapaFinished);
                                 mixer.addEventListener('finished', onTarjetaFinished);
                            } else {
                                console.warn("JS: Mixer no está inicializado, no se pueden añadir listeners de 'finished'. El estado podría no actualizarse correctamente.");
                                // Como fallback, si el mixer no está, podríamos usar un setTimeout basado en la duración esperada
                                // const duracionEstimadaMs = (50 / 30) * 1000; // Asumiendo 50 frames a 30fps
                                // setTimeout(() => {
                                //     if (estadoApp3D === "ANIMANDO_SOBRE_TARJETA") {
                                //         estadoApp3D = "TARJETA_MOSTRADA";
                                //         console.log("JS: Estado cambiado a TARJETA_MOSTRADA (por timeout).");
                                //     }
                                // }, duracionEstimadaMs + 200); // +200ms de margen
                            }

                        } else {
                            console.error("JS: No se pudieron iniciar una o ambas animaciones (Solapa_Abrir o Tarjeta_Salir).");
                            estadoApp3D = "INICIO";
                        }

                    // ... el resto de tu lógica de onCanvasPointerDown ...
                    } else if (estadoApp3D === "TARJETA_MOSTRADA" && primerObjetoTocado.name === NOMBRE_TARJETA) {
                        // ... (tu lógica existente para cuando se toca la tarjeta mostrada) ...
                        // Esta parte no cambia por ahora
                        console.log("JS: Interacción TARJETA_MOSTRADA -> Mostrar Tarjeta en Grande");
                        if (window.AndroidBridge && typeof window.AndroidBridge.onTarjeta3DTocada === 'function') {
                            window.AndroidBridge.onTarjeta3DTocada();
                        } else {
                            console.log("JS: AndroidBridge no disponible. Simulando flujo...");
                            window.ocultarTarjetaYSobre();
                            window.actualizarEstado3DDesdeKotlin("TARJETA_LEIDA");
                            if (controls) controls.reset(); // FIX MOVIMIENTO
                        }

                    } else if (estadoApp3D === "TARJETA_LEIDA" && LAZOS.includes(primerObjetoTocado.name)) {
                        // FIX INTERACCIÓN: Solo reacciona a los lazos

                        // ... (tu lógica existente para cuando se toca el lazo) ...
                        // Esta parte no cambia por ahora
                        console.log("JS: Interacción TARJETA_LEIDA -> Abrir Regalo Principal");
                        estadoApp3D = "ABRIENDO_REGALO";
                        const lazoE = gltfModel.getObjectByName(NOMBRE_LAZO_ESTRELLA);
                        const lazoF = gltfModel.getObjectByName(NOMBRE_LAZO_FLOR);
                        const lazoN = gltfModel.getObjectByName(NOMBRE_LAZO_NORMAL);
                        const lazoD = gltfModel.getObjectByName(NOMBRE_LAZO_DORADO);
                        const cinta1 = gltfModel.getObjectByName(NOMBRE_CINTA1);
                        const cinta2 = gltfModel.getObjectByName(NOMBRE_CINTA2);
                        
                        // 1. Ocultar todos los lazos y cintas
                        [lazoE, lazoF, lazoN, lazoD, cinta1, cinta2].forEach(obj => {
                            if (obj) obj.visible = false;
                        });
                        console.log("JS: Lazos y cintas ocultados.");

                        // Pequeña demora antes de que caigan los papeles
                        setTimeout(() => {
                            console.log("JS: Iniciando caída de papeles.");                            
                            let papelesCaidos = 0;
                            PAPELES.forEach(nombrePapel => {
                                const papelObj = gltfModel.getObjectByName(nombrePapel);
                                if (papelObj) papelObj.visible = true;
                                playAnimacion(`${nombrePapel}_Caer`, () => {
                                    papelesCaidos++;
                                    if (papelesCaidos === PAPELES.length) {
                                        // Cuando el último papel cae, abrimos la tapa
                                        console.log("JS: Todos los papeles han caído.");
                                        const tapaObj = gltfModel.getObjectByName(NOMBRES.TAPA);
                                        if (tapaObj) tapaObj.visible = true;
                                        playAnimacion("Tapa_Abrir", () => {
                                            console.log("JS: Tapa abierta. Lanzando confeti...");
                                            iniciarAnimacionConfeti(() => {
                                                console.log("JS: Animación de confeti terminada. Notificando a Kotlin.");
                                                if (window.AndroidBridge) window.AndroidBridge.onAnimacionAperturaCompleta();
                                            });
                                            estadoApp3D = "REGALO_ABIERTO";
                                        });
                                    }
                                });
                            })
                                            console.log("JS: Todos los papeles han caído.");
                                            // 3. Abrir la tapa
                                            const tapaObj = gltfModel.getObjectByName(NOMBRE_TAPA);
                                            if (tapaObj) tapaObj.visible = true; // Asegurar visibilidad

                                            window.playAnimacion("Tapa_Abrir", (tapaSuccess) => {
                                                if (tapaSuccess) {
                                                    console.log("JS: Tapa abierta. Lanzando confeti...");
                                                    // 4. Iniciar la animación de confeti y pasarle un callback
                                                    window.iniciarAnimacionConfetiCompleta(function() {
                                                        // 5. Este código se ejecuta DESPUÉS de 14 segundos
                                                        console.log("JS: Animación de confeti terminada. Notificando a Kotlin.");
                                                        window.AndroidBridge.onAnimacionAperturaCompleta();
                                                    });
                                                    estadoApp3D = "REGALO_ABIERTO";
                                                } else {
                                                    console.error("JS: Falló la animación de apertura de tapa.");
                                                    estadoApp3D = "TARJETA_LEIDA"; // Volver al estado anterior o manejar error
                                                }
                                            });
                            });
                        }, 500); // 500ms de espera
                    } else {
                        console.log(`JS: Toque en '${primerObjetoTocado.name}' ignorado en estado '${estadoApp3D}'.`);
                    }
                }
            }
            // --- FIN NUEVA FUNCIÓN ---

            // ==================================================================
            // === FUNCIONES DEL CONFETI ADAPTADAS Y AÑADIDAS A WINDOW ==========
            // ==================================================================
            // (Aquí pegaremos todo el bloque de funciones adaptadas)
            // PEGA ESTE BLOQUE ENTERO EN viewer.html, en la línea 300 aprox.

            window.crearMeshConfeti = function() {
                var geo = new THREE.BufferGeometry();
                var quads = totalConfeti, tris = quads*2, chunk = 21845;
                var pos = new Float32Array(tris*3*3), anim = new Float32Array(tris*3*2), trans = new Float32Array(tris*3*3),
                    c0 = new Float32Array(tris*3*3), c1 = new Float32Array(tris*3*3), giro = new Float32Array(tris*3*4),
                    fcol = new Float32Array(tris*3*3), bcol = new Float32Array(tris*3*3), ind = new Uint16Array(tris*3);

                geo.addAttribute('index', new THREE.BufferAttribute(ind,1));
                geo.addAttribute('anim', new THREE.BufferAttribute(anim,2));
                geo.addAttribute('position', new THREE.BufferAttribute(pos,3));
                geo.addAttribute('desplazamiento', new THREE.BufferAttribute(trans,3));
                geo.addAttribute('control0', new THREE.BufferAttribute(c0,3));
                geo.addAttribute('control1', new THREE.BufferAttribute(c1,3));
                geo.addAttribute('giro', new THREE.BufferAttribute(giro,4));
                geo.addAttribute('colorF', new THREE.BufferAttribute(fcol,3));
                geo.addAttribute('colorT', new THREE.BufferAttribute(bcol,3));

                for(let i=0;i<ind.length;i++){ind[i]=i%(3*chunk);}
                for(let i=0;i<anim.length;i+=12){ let d=Math.random()*4,l=6+Math.random()*4; for(let j=0;j<12;j+=2){anim[i+j]=d;anim[i+j+1]=l;} }
                var hw=0.02,hh=hw*0.6, a=[-hw,hh,0], b=[hw,hh,0], c=[hw,-hh,0], d=[-hw,-hh,0], verts=[a,d,b,d,c,b];
                for(let i=0,v=0;i<pos.length;i+=18){ v=0; for(let j=0;j<18;j+=3){pos[i+j]=verts[v][0];pos[i+j+1]=verts[v][1];pos[i+j+2]=verts[v][2];v++;} }
                for(let i=0;i<trans.length;i+=18){ let phi=Math.random()*Math.PI*2,r=4,x=rand(-4,4),z=rand(-4,4),dx=x+r*Math.cos(phi)*Math.random(),dz=z+r*Math.sin(phi)*Math.random(); for(let j=0;j<18;j+=3){trans[i+j]=dx;trans[i+j+1]=0;trans[i+j+2]=dz;} }
                for(let i=0;i<c0.length;i+=18){ let cp0=[rand(-1,1),rand(6,10),rand(-1,1)],cp1=[rand(-8,8),rand(2,10),rand(-8,8)]; for(let j=0;j<18;j+=3){c0[i+j]=cp0[0];c0[i+j+1]=cp0[1];c0[i+j+2]=cp0[2];c1[i+j]=cp1[0];c1[i+j+1]=cp1[1];c1[i+j+2]=cp1[2];} }
                for(let i=0;i<giro.length;i+=24){ let ax=Math.random(),az=Math.random(),ang=Math.PI*rand(20,60),len=Math.sqrt(ax*ax+az*az);ax/=len;az/=len; for(let j=0;j<24;j+=4){giro[i+j]=ax;giro[i+j+1]=0;giro[i+j+2]=az;giro[i+j+3]=ang;} }
                var f=new THREE.Color(),t=new THREE.Color();
                for(let i=0;i<fcol.length;i+=18){ let h=Math.random();f.setHSL(h,1.0,0.5);t.setHSL(h,0.65,0.5); for(let j=0;j<18;j+=3){fcol[i+j]=f.r;fcol[i+j+1]=f.g;fcol[i+j+2]=f.b;bcol[i+j]=t.r;bcol[i+j+1]=t.g;bcol[i+j+2]=t.b;} }
                for(let i=0;i<tris/chunk;i++){ geo.drawcalls.push({start:i*chunk*3,index:i*chunk*3,count:Math.min(tris-(i*chunk),chunk)*3}); }

                var attr={anim:{type:"v2",value:null},desplazamiento:{type:"v3",value:null},control0:{type:"v3",value:null},control1:{type:"v3",value:null},giro:{type:"v4",value:null},colorF:{type:"c",value:null},colorT:{type:"c",value:null}},
                    uni={tiempo:{type:"f",value:0}};
                var material=new THREE.ShaderMaterial({attributes:attr,uniforms:uni,vertexShader:document.getElementById('vs-confeti').textContent,fragmentShader:document.getElementById('fs-confeti').textContent,side:THREE.DoubleSide});
                meshConfeti=new THREE.Mesh(geo,material);
                meshConfeti.material.uniforms=uni;
                scene.add(meshConfeti);
            };

            window.prepararTextoConfeti = function() {
                lienzoTextoConfeti=document.getElementById('texto-confeti');
                ctxTextoConfeti=lienzoTextoConfeti.getContext('2d');
                lienzoTextoConfeti.width=window.innerWidth;
                lienzoTextoConfeti.height=200;
            };

            window.actualizarTextoConfeti = function() {
                if(!ctxTextoConfeti)return;
                var msg=document.getElementById('entrada-confeti').value||'¡DISFRUTA TU REGALO!';
                var s=window.innerWidth/(msg.length*0.8); if(s>160)s=160;
                ctxTextoConfeti.font='700 '+s+'px Arial';
                ctxTextoConfeti.clearRect(0,0,lienzoTextoConfeti.width,lienzoTextoConfeti.height);
                ctxTextoConfeti.textAlign='center'; ctxTextoConfeti.textBaseline='middle'; ctxTextoConfeti.fillStyle = '#000000';
                ctxTextoConfeti.fillText(msg.toUpperCase(),lienzoTextoConfeti.width/2,lienzoTextoConfeti.height/2);
                var datos=ctxTextoConfeti.getImageData(0,0,lienzoTextoConfeti.width,lienzoTextoConfeti.height).data;
                pixelesConfeti=[];
                for(let i=0;i<datos.length;i+=4){ if(datos[i+3] > 128){ let x=(i/4)%lienzoTextoConfeti.width, y=Math.floor((i/4)/lienzoTextoConfeti.width); if(x%2===0 && y%2===0){ pixelesConfeti.push({x: x, y: y}); } } }
            };

            window.crearCubosConfeti = function() {
                if(grupoTextoConfeti){ scene.remove(grupoTextoConfeti); }
                grupoTextoConfeti=new THREE.Object3D(); cubosConfeti=[];
                for(let i=0;i<pixelesConfeti.length;i++){
                    let c={};
                    c.rotX=Math.random()*0.05; c.rotY=Math.random()*0.05;
                    c.obj=new THREE.Mesh(new THREE.BoxGeometry(0.03,0.05,0.07), new THREE.MeshLambertMaterial({color:new THREE.Color().setHSL(Math.random(),0.8,0.7)}));
                    c.destino=new THREE.Vector3();
                    let pixel = pixelesConfeti[i];
                    let x = (pixel.x - lienzoTextoConfeti.width/2) * (10 / window.innerWidth);
                    let y = (lienzoTextoConfeti.height/2 - pixel.y) * (5 / 200);
                    c.destino.set(x, y + 1.5, 0);
                    let radio=15,r=5+radio*Math.random(),ang=Math.random()*Math.PI*2;
                    c.obj.position.set(r*Math.cos(ang), r*Math.sin(ang), Math.random()*10-5);
                    grupoTextoConfeti.add(c.obj); cubosConfeti.push(c);
                }
                scene.add(grupoTextoConfeti);
            };

            window.actualizarCubosConfeti = function() {
                for(let i=0;i<cubosConfeti.length;i++){
                    let c = cubosConfeti[i];
                    if(c.obj.position.distanceTo(c.destino) > 0.05){
                        c.obj.rotation.x+=c.rotX; c.obj.rotation.y+=c.rotY;
                        c.obj.position.lerp(c.destino,0.03);
                    } else {
                        c.obj.position.copy(c.destino); c.obj.rotation.set(0,0,0);
                        c.obj.material.color.set(0xff3333);
                    }
                }
            };

            window.iniciarAnimacionConfetiCompleta = function(callbackCuandoTermine) {
                tiempoConfeti = 0;
                if (meshConfeti) meshConfeti.visible = true; // Asegurarse de que sea visible
                mostrarConfeti = true;
                window.actualizarTextoConfeti();
                window.crearCubosConfeti();

                // Usamos setTimeout para simular la duración y llamar al callback
                setTimeout(function() {
                    window.detenerAnimacionConfeti();
                    if (callbackCuandoTermine) callbackCuandoTermine();
                }, 14000); // 14 segundos
            };

            window.detenerAnimacionConfeti = function() {

                if (meshConfeti) scene.remove(meshConfeti);
                if (grupoTextoConfeti) scene.remove(grupoTextoConfeti);
                mostrarConfeti = false;
            };

            function rand(a,b){ return Math.random()*(b-a)+a; }
            // --- FUNCIONES GLOBALES (COMO EN TU v14 - ASIGNADAS A WINDOW) ---
            window.applyTexture = function(meshName, relativeTexturePath, makeVisible = false) {
                 // console.log(`JS: applyTexture: ${meshName}, ${relativeTexturePath}`);
                 if (!gltfModel || !relativeTexturePath) return;
                 const fullTexturePath = `/assets/texturas/${relativeTexturePath}`;
                 textureLoader.load(fullTexturePath, (texture) => {
                     texture.flipY = false; texture.colorSpace = THREE.SRGBColorSpace;
                     const targetObject = gltfModel.getObjectByName(meshName);
                     if (targetObject && targetObject.isMesh) {
                         if (!targetObject.material) targetObject.material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                         else if (!targetObject.material.map && targetObject.material.color) targetObject.material.color.set(0xFFFFFF);

                         if (targetObject.material.map !== undefined) {
                             targetObject.material.map = texture;
                             targetObject.material.needsUpdate = true;
                             if(makeVisible && !targetObject.visible) targetObject.visible = true;
                         } else console.warn(`JS: Material de '${meshName}' no soporta .map`);
                     } else {
                         // console.warn(`JS: Malla '${meshName}' no encontrada para textura.`);
                     }
                 }, undefined, (err) => console.error(`JS: Error cargando textura '${fullTexturePath}' para ${meshName}:`, err));
             };

            // --- NUEVA FUNCIÓN PARA MAPAS DE DETALLE (NORMAL/ROUGHNESS) ---
            window.applyDetailMap = function(meshName, relativeTexturePath, mapType = 'normal') {
                const fullPath = `/app/src/main/assets/texturas/details/${relativeTexturePath}`; // <-- CORRECCIÓN
                console.log(`JS: applyDetailMap: ${meshName}, Cargando desde: ${fullPath}, tipo: ${mapType}`);
                if (!gltfModel || !relativeTexturePath) return;
                textureLoader.load(fullPath, (texture) => {
                    texture.flipY = false;
                    const targetObject = gltfModel.getObjectByName(meshName);
                    if (targetObject && targetObject.isMesh && targetObject.material) {
                        if (mapType === 'normal') {
                            targetObject.material.normalMap = texture;
                            // Ajusta la intensidad del normal map si es necesario
                            targetObject.material.normalScale = new THREE.Vector2(0.5, 0.5);
                        } else if (mapType === 'roughness') {
                            targetObject.material.roughnessMap = texture;
                        }
                        targetObject.material.needsUpdate = true;
                    } else {
                        console.warn(`JS: Malla '${meshName}' o su material no encontrada para detail map.`);
                    }
                }, undefined, (err) => console.error(`JS: Error cargando detail map '${fullPath}':`, JSON.stringify(err)));
            };

            // Definición de window.cambiarFormaLazo
            window.cambiarFormaLazo = function(nombreFormaLazoActiva) {
                console.log(`JS: cambiarFormaLazo a: ${nombreFormaLazoActiva}`);
                if (!gltfModel) return;
                const todosLosLazosPosibles = [NOMBRE_LAZO_ESTRELLA, NOMBRE_LAZO_FLOR, NOMBRE_LAZO_NORMAL, NOMBRE_LAZO_DORADO];

                todosLosLazosPosibles.forEach(nombreLazo => {
                    const lazoObj = gltfModel.getObjectByName(nombreLazo);
                    if (lazoObj) {
                        lazoObj.visible = (nombreLazo === nombreFormaLazoActiva);
                    }
                });

                const cinta1Obj = gltfModel.getObjectByName(NOMBRE_CINTA1);
                const cinta2Obj = gltfModel.getObjectByName(NOMBRE_CINTA2);
                const hayLazoActivo = nombreFormaLazoActiva && nombreFormaLazoActiva.length > 0 && todosLosLazosPosibles.includes(nombreFormaLazoActiva);

                if (cinta1Obj) cinta1Obj.visible = hayLazoActivo;
                if (cinta2Obj) cinta2Obj.visible = hayLazoActivo;
                 console.log(`JS: Lazo activo: ${nombreFormaLazoActiva}, Cintas visibles: ${hayLazoActivo}`);
            };


            window.applyColor = function(meshName, colorHex, makeVisible = false, roughnessValue = 0.2) {
                // console.log(`JS: applyColor: ${meshName}, ${colorHex}, visible: ${makeVisible}, rough: ${roughnessValue}`);
                if (!gltfModel) return;
                const targetObject = gltfModel.getObjectByName(meshName);
                if (targetObject && targetObject.isMesh) {
                    if (!targetObject.material || !targetObject.material.isMeshStandardMaterial) {
                        const oldColorHex = targetObject.material && targetObject.material.color ? targetObject.material.color.getHex() : 0xFFFFFF;
                        if(targetObject.material) targetObject.material.dispose();
                        targetObject.material = new THREE.MeshStandardMaterial({
                            color: colorHex ? new THREE.Color(colorHex) : oldColorHex,
                            roughness: roughnessValue
                        });
                    } else {
                        if (colorHex) {
                            try {
                                targetObject.material.color.set(new THREE.Color(colorHex));
                                if (targetObject.material.map) targetObject.material.map = null;
                            } catch (e) { console.error(`JS: Error color '${colorHex}' en '${meshName}':`, e); return; }
                        }
                        targetObject.material.roughness = roughnessValue;
                    }
                    targetObject.material.needsUpdate = true;
                    if(makeVisible && !targetObject.visible) targetObject.visible = true;
                } else {
                    // console.warn(`JS: Malla '${meshName}' no encontrada para color/roughness.`);
                }
            };

            // Definición de window.ocultarTarjetaYSobre
            window.ocultarTarjetaYSobre = function() {
                console.log("JS: ocultarTarjetaYSobre() llamado.");
                if (!gltfModel) return;
                const tarjetaObj = gltfModel.getObjectByName(NOMBRE_TARJETA);
                const sobreObj = gltfModel.getObjectByName(NOMBRE_SOBRE);
                const solapaObj = gltfModel.getObjectByName(NOMBRE_SOLAPA); // La solapa también debería ocultarse

                if (tarjetaObj) tarjetaObj.visible = false;
                if (sobreObj) sobreObj.visible = false;
                if (solapaObj) solapaObj.visible = false;
                console.log("JS: Tarjeta, Sobre y Solapa ocultados.");
            };


            window.aplicarTexturaCaja = function(t) { window.applyTexture(NOMBRE_CAJA, `packages/${t}`, true); };
            window.aplicarTexturaMesa = function(t) { window.applyTexture(NOMBRE_MESA, `table/${t}`, true); }; // Nueva función para la mesa
            window.aplicarTexturaPapel = function(texturaPathRelativa, detalleTexturaPath) {
                const piezasPapel = [NOMBRE_PAPEL_FRONTAL, NOMBRE_PAPEL_TRASERO, NOMBRE_PAPEL_IZQUIERDO, NOMBRE_PAPEL_DERECHO, NOMBRE_PAPEL_INFERIOR, NOMBRE_PAPEL_SUPERIOR];
                piezasPapel.forEach(pieza => {
                    window.applyTexture(pieza, `paper/${texturaPathRelativa}`, true);
                    if (detalleTexturaPath) {
                        window.applyDetailMap(pieza, `details/${detalleTexturaPath}`);
                    }
                });
            };
            window.aplicarTexturaTarjeta = function(t) { window.applyTexture(NOMBRE_TARJETA, `cards/${t}`, false); };
            window.aplicarColorYAcabadoLazoYCintas = function(nombreObjetoLazoActivo, colorHex, acabadoString, detalleTexturaPath) {
                if (!gltfModel || !colorHex || !acabadoString) return;
                console.log(`JS: aplicando color ${colorHex} y acabado ${acabadoString} a lazo ${nombreObjetoLazoActivo} y cintas.`);
                let roughnessTarget = (acabadoString.toLowerCase() === "mate") ? 0.85 : 0.15;

                // Aplicar al lazo activo (si existe y es uno de los que manejamos)
                if(nombreObjetoLazoActivo) window.applyColor(nombreObjetoLazoActivo, colorHex, true, roughnessTarget);
                window.applyColor(NOMBRE_CINTA1, colorHex, true, roughnessTarget);
                window.applyColor(NOMBRE_CINTA2, colorHex, true, roughnessTarget);

                // Aplicar textura de detalle a las cintas y al lazo
                if (detalleTexturaPath) {
                    if(nombreObjetoLazoActivo) window.applyDetailMap(nombreObjetoLazoActivo, `details/${detalleTexturaPath}`);
                    window.applyDetailMap(NOMBRE_CINTA1, `details/${detalleTexturaPath}`);
                    window.applyDetailMap(NOMBRE_CINTA2, `details/${detalleTexturaPath}`);
                }
            };
            window.playAnimacion = function(nombreAnim, onFinishedCallback) {
                console.log(`JS: playAnimacion('${nombreAnim}') solicitado.`);
                if (!mixer || !animations || !nombreAnim) {
                    console.warn('JS: playAnimacion saltada (sin mixer/animations/nombre).');
                    if (onFinishedCallback) onFinishedCallback(false);
                    return null;
                }

                const clip = THREE.AnimationClip.findByName(animations, nombreAnim);
                if (clip) {
                    const action = mixer.clipAction(clip);
                    action.reset();
                    action.loop = THREE.LoopOnce;
                    action.clampWhenFinished = true;

                    if (onFinishedCallback) {
                        const listener = (event) => {
                            if (event.action === action) {
                                console.log(`JS: Animación '${nombreAnim}' finalizada.`);
                                mixer.removeEventListener('finished', listener);
                                onFinishedCallback(true);
                            }
                        };
                        mixer.addEventListener('finished', listener);
                    }

                    action.play();
                    console.log(`JS: Animación '${nombreAnim}' iniciada.`);
                    return action;
                } else {
                    console.warn(`JS: Animación '${nombreAnim}' no encontrada.`);
                    if (onFinishedCallback) onFinishedCallback(false);
                    return null;
                }
            };


            window.actualizarEstado3DDesdeKotlin = function(nuevoEstado) {
                console.log(`JS: Kotlin actualizó estado3D de '${estadoApp3D}' a '${nuevoEstado}'`);
                estadoApp3D = nuevoEstado;
            };

            console.log("VIEWER.HTML: Funciones globales listas (v16.1).");

        } catch (error) {
            console.error("VIEWER.HTML: Error FATAL (v16.1):", error);
            loadingIndicator.textContent = 'Error crítico JS!';
            if (error.stack) console.error("Stack (v16.1):", error.stack);
        }
    })();
</script>
</body>
</html>
